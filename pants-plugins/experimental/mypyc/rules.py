from dataclasses import dataclass
from decimal import DivisionByZero
import logging
import os
from pathlib import Path

from pants.backend.python.goals.setup_py import (
    DistBuildChroot,
    DistBuildChrootRequest,
    DistBuildRequest,
    DistBuildResult,
    ExportedTarget,
    PythonProvidesField,
    NoDistTypeSelected,
    SetupKwargs,
    SetupKwargsRequest,
    SETUP_BOILERPLATE,
    SetupPyContentRequest,
    SetupPyContent,
    WheelConfigSettingsField,
    WheelField
)
from pants.backend.python.util_rules.interpreter_constraints import InterpreterConstraints
from pants.core.goals.package import BuiltPackage, BuiltPackageArtifact, PackageFieldSet
from pants.backend.python.subsystems.setup import PythonSetup
from pants.backend.python.util_rules.dists import (
    distutils_repr,
    BuildSystem, 
    BuildSystemRequest,
)
from pants.backend.python.util_rules.python_sources import (
    PythonSourceFilesRequest,
    PythonSourceFiles,
)
from pants.engine.fs import AddPrefix, CreateDigest, Digest, FileContent, Snapshot
from pants.engine.rules import Get, collect_rules, rule
from pants.engine.target import Target, TransitiveTargets, TransitiveTargetsRequest
from pants.engine.unions import UnionRule
from pants.util.frozendict import FrozenDict
from pants.util.logging import LogLevel

from experimental.mypyc.target_types import MyPycPythonDistribution

logger = logging.getLogger(__name__)


MYPYC_SETUP_BOILERPLATE = """
# DO NOT EDIT THIS FILE -- AUTOGENERATED BY PANTS
# Target: {target_address_spec}
# mypy: ignore-errors

from setuptools import setup, Extension
from mypyc.build import mypycify

setup(**{setup_kwargs_str}, ext_modules=mypycify({mypycify_files}),)
"""
 
@dataclass(frozen=True)
class MyPycSetupKwargsRequest(SetupKwargsRequest):
    @classmethod
    def is_applicable(cls, target: Target) -> bool:
        return isinstance(target, MyPycPythonDistribution)

@rule(level=LogLevel.DEBUG)
async def mypyc_setup_kwargs(request: MyPycSetupKwargsRequest) -> SetupKwargs:
    logger.info(f"mypyc_setup_kwargs: Running on requested target: {request.target}")
    transitive_targets = await Get(
        TransitiveTargets,
        TransitiveTargetsRequest([request.target.address]),
    )
    logger.info(f"mypyc_setup_kwargs: Transitive targets of {request.target.address} : {transitive_targets}")

    logger.info(f"mypyc_setup_kwargs: Dependencies {transitive_targets.dependencies}")

    python_source_files = (
        await Get(
            PythonSourceFiles,
            PythonSourceFilesRequest(
                transitive_targets.closure, include_resources=False, include_files=False
            ),
        ),
    )
    
    # TODO: Handle multiple PythonSourceFiles
    logger.debug(f"mypyc_setup_kwargs: Internals of the retrieved PythonSourceFiles: {python_source_files[0]}")
    source_files = [Path(file) for file in python_source_files[0].source_files.snapshot.files]
    # TODO: Handle multiple source roots
    source_root = python_source_files[0].source_roots[0]
    relative_source_files = [str(file.relative_to(source_root)) for file in source_files]

    kwargs = SetupKwargs(
        {
            **request.explicit_kwargs,
            "mypycify_files": relative_source_files,
        },
        address=request.target.address,
    )
    logger.debug(f"mypyc_setup_kwargs: Resulting SetupKwargs: {kwargs.kwargs}")
    return kwargs


class MyPycSetupPyContentRequest(SetupPyContentRequest):
    @classmethod
    def is_applicable(cls, target: Target) -> bool:
        return isinstance(target, MyPycPythonDistribution)

@rule(level=LogLevel.DEBUG)
async def generate_setup_py_content(request: MyPycSetupPyContentRequest) -> SetupPyContent:
    setup_kwargs = request.finalized_setup_kwargs.kwargs
    mypycify_files = setup_kwargs.pop("mypycify_files", [])

    template = MYPYC_SETUP_BOILERPLATE 
    if not mypycify_files:
        logger.warning("generate_setup_py_content: No mypyc files were specified. Expecting a key named 'mypycify_files' with a list of source file paths")
        template = SETUP_BOILERPLATE

    # TODO: What happens if "ext_modules" was already specified in kwargs? Need to merge or error out as unsupported
    content = template.format(
        target_address_spec=request.target.address.spec,
        setup_kwargs_str=distutils_repr(setup_kwargs),
        mypycify_files=distutils_repr(mypycify_files),
    ).encode()
    logger.debug(f"generate_setup_py_content: Generating mypyc setup.py: {content}")
    return SetupPyContent(content)

@dataclass(frozen=True)
class MyPycPythonDistributionFieldSet(PackageFieldSet):
    required_fields = (PythonProvidesField,)

    provides: PythonProvidesField


@rule(level=LogLevel.DEBUG)
async def package_mypyc_python_dist(
    field_set: MyPycPythonDistributionFieldSet,
    python_setup: PythonSetup,
) -> BuiltPackage:

    transitive_targets = await Get(TransitiveTargets, TransitiveTargetsRequest([field_set.address]))
    exported_target = ExportedTarget(transitive_targets.roots[0])

    dist_tgt = exported_target.target
    wheel = dist_tgt.get(WheelField).value
    # sdist = dist_tgt.get(SDistField).value
    if not wheel:
        raise NoDistTypeSelected(f"In order to package {dist_tgt.address.spec}, {WheelField.alias!r} or must be `True`.")

    wheel_config_settings = dist_tgt.get(WheelConfigSettingsField).value or FrozenDict()
    # sdist_config_settings = dist_tgt.get(SDistConfigSettingsField).value or FrozenDict()

    interpreter_constraints = InterpreterConstraints.create_from_targets(
        transitive_targets.closure, python_setup
    ) or InterpreterConstraints(python_setup.interpreter_constraints)
    chroot = await Get(
        DistBuildChroot,
        DistBuildChrootRequest(
            exported_target,
            py2=interpreter_constraints.includes_python2(),
        ),
    )

    # We prefix the entire chroot, and run with this prefix as the cwd, so that we can capture
    # any changes setup made within it without also capturing other artifacts of the pex
    # process invocation.
    chroot_prefix = "chroot"
    working_directory = os.path.join(chroot_prefix, chroot.working_directory)
    prefixed_chroot = await Get(Digest, AddPrefix(chroot.digest, chroot_prefix))
    dist_snapshot = await Get(Snapshot, Digest, chroot.digest)
    logger.info(f"Dist snapshot: {dist_snapshot}")
    build_system = await Get(BuildSystem, BuildSystemRequest(prefixed_chroot, working_directory))
    logger.info(f"Build system: {build_system}")
    setup_py_result = await Get(
        DistBuildResult,
        DistBuildRequest(
            build_system=build_system,
            interpreter_constraints=interpreter_constraints,
            build_wheel=wheel,
            build_sdist=False,
            input=prefixed_chroot,
            working_directory=working_directory,
            target_address_spec=exported_target.target.address.spec,
            wheel_config_settings=wheel_config_settings,
            # sdist_config_settings=sdist_config_settings,
        ),
    )

    # build_backend_pex = await Get(
    #     VenvPex,
    #     PexRequest(
    #         output_filename="build_backend.pex",
    #         internal_only=True,
    #         requirements=request.build_system.requires,
    #         interpreter_constraints=request.interpreter_constraints,
    #     ),
    # )

    dist_snapshot = await Get(Snapshot, Digest, setup_py_result.output)
    # empty_digest = await Get(Digest, CreateDigest([FileContent("f1.txt", b"hello world")]))
    logger.info(dist_snapshot)
    return BuiltPackage(
        setup_py_result.output,
        tuple(BuiltPackageArtifact(path) for path in dist_snapshot.files),
    )



def rules():
    return (
        *collect_rules(),
        UnionRule(SetupKwargsRequest, MyPycSetupKwargsRequest),
        UnionRule(SetupPyContentRequest, MyPycSetupPyContentRequest),
        UnionRule(PackageFieldSet, MyPycPythonDistributionFieldSet),
    )
