from dataclasses import dataclass
import logging
from pathlib import Path

from pants.backend.python.goals.setup_py import (
    SetupKwargs,
    SetupKwargsRequest,
    SETUP_BOILERPLATE,
    SetupPyContentRequest,
    SetupPyContent,
)
from pants.backend.python.util_rules.dists import (
    distutils_repr,
)
from pants.backend.python.util_rules.python_sources import (
    PythonSourceFilesRequest,
    PythonSourceFiles,
)
from pants.engine.rules import Get, collect_rules, rule
from pants.engine.target import Target, TransitiveTargets, TransitiveTargetsRequest
from pants.engine.unions import UnionRule

from experimental.mypyc.target_types import MyPycPythonDistribution
from pants.util.logging import LogLevel

logger = logging.getLogger(__name__)


MYPYC_SETUP_BOILERPLATE = """
# DO NOT EDIT THIS FILE -- AUTOGENERATED BY PANTS
# Target: {target_address_spec}
# mypy: ignore-errors

from setuptools import setup, Extension
from mypyc.build import mypycify

setup(**{setup_kwargs_str}, ext_modules=mypycify({mypycify_files}),)
"""
 
@dataclass(frozen=True)
class MyPycSetupKwargsRequest(SetupKwargsRequest):
    @classmethod
    def is_applicable(cls, target: Target) -> bool:
        return isinstance(target, MyPycPythonDistribution)

@rule(level=LogLevel.DEBUG)
async def mypyc_setup_kwargs(request: MyPycSetupKwargsRequest) -> SetupKwargs:
    logger.debug(f"mypyc_setup_kwargs: Running on requested target: {request.target}")
    transitive_targets = await Get(
        TransitiveTargets,
        TransitiveTargetsRequest([request.target.address]),
    )
    logger.debug(f"mypyc_setup_kwargs: Transitive targets of {request.target.address} : {transitive_targets}")

    python_source_files = (
        await Get(
            PythonSourceFiles,
            PythonSourceFilesRequest(
                transitive_targets.closure, include_resources=False, include_files=False
            ),
        ),
    )
    
    # TODO: Handle multiple PythonSourceFiles
    logger.debug(f"mypyc_setup_kwargs: Internals of the retrieved PythonSourceFiles: {python_source_files[0]}")
    source_files = [Path(file) for file in python_source_files[0].source_files.snapshot.files]
    # TODO: Handle multiple source roots
    source_root = python_source_files[0].source_roots[0]
    relative_source_files = [str(file.relative_to(source_root)) for file in source_files]

    kwargs = SetupKwargs(
        {
            **request.explicit_kwargs,
            "mypycify_files": relative_source_files,
        },
        address=request.target.address,
    )
    logger.debug(f"mypyc_setup_kwargs: Resulting SetupKwargs: {kwargs.kwargs}")
    return kwargs


class MyPycSetupPyContentRequest(SetupPyContentRequest):
    @classmethod
    def is_applicable(cls, target: Target) -> bool:
        return isinstance(target, MyPycPythonDistribution)

@rule(level=LogLevel.DEBUG)
async def generate_setup_py_content(request: MyPycSetupPyContentRequest) -> SetupPyContent:
    setup_kwargs = request.finalized_setup_kwargs.kwargs
    mypycify_files = setup_kwargs.pop("mypycify_files", [])

    template = MYPYC_SETUP_BOILERPLATE 
    if not mypycify_files:
        logger.warning("generate_setup_py_content: No mypyc files were specified. Expecting a key named 'mypycify_files' with a list of source file paths")
        template = SETUP_BOILERPLATE

    # TODO: What happens if "ext_modules" was already specified in kwargs? Need to merge or error out as unsupported
    content = template.format(
        target_address_spec=request.target.address.spec,
        setup_kwargs_str=distutils_repr(setup_kwargs),
        mypycify_files=distutils_repr(mypycify_files),
    ).encode()
    logger.debug(f"generate_setup_py_content: Generating mypyc setup.py: {content}")
    return SetupPyContent(content)


def rules():
    return (
        *collect_rules(),
        UnionRule(SetupKwargsRequest, MyPycSetupKwargsRequest),
        UnionRule(SetupPyContentRequest, MyPycSetupPyContentRequest),
    )
